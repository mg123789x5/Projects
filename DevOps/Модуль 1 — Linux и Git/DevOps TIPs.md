

---
Руководство по запуску и управлению собственным программным обеспечением и серверами дома или на работе — [Self-Hosting-Guide](https://github.com/mikeroyal/Self-Hosting-Guide)

---
### Вещи, которые вы должны автоматизировать, но, вероятно, ещё не автоматизировали...

- [ ] Резервные копии базы данных: 
      Плановые, протестированные и хранящиеся вне основной инфраструктуры — а не "когда вспомню".

- [ ] Удаление устаревших веток: 
      Очищайте старые Git-ветки как в локальном репозитории, так и в удалённом.

- [ ] Очистка просроченных feature-флагов: 
      Устаревшие флаги несут риски и путаницу — автоудаляйте их после завершения использования.

- [ ] Обновление зависимостей: 
      Используйте ботов вроде Dependabot или Renovate, чтобы избежать неожиданных сбоев.

- [ ] Скрипты настройки окружения: 
      Shell-скрипты или Dockerfile лучше пошаговых wiki-инструкций.

- [ ] Генерация release-заметок: 
      Автоматическая генерация на основе названий PR или сообщений коммитов.

- [ ] Provisioning инфраструктуры: 
      Используйте Terraform/CloudFormation вместо ручного управления через облачные консоли.

- [ ] Миграции схемы БД: 
      Применяйте версионированные миграции при деплое, а не вручную.

- [ ] Ротация и архивирование логов: 
      Не допускайте незаметного заполнения дисков.

- [ ] Продление SSL-сертификатов: 
      Не допускайте падения продакшена из-за просроченного Let's Encrypt.

- [ ] Алерты на аномальные паттерны: 
      Настройте оповещения не только на ошибки, но и на отсутствие запросов, логов или резкие всплески.

- [ ] Мониторинг Dead Letter Queue (DLQ): 
      Алерты при непустом DLQ лучше, чем обнаружение проблемы через месяц.

- [ ] Отчёты об успешности Cron-задач: 
      Следите, если плановые задачи упали или вовсе не запускались.

- [ ] Отчёты о покрытии тестами: 
      Автоматически публикуйте результаты и статистику покрытия после каждого билда.

- [ ] Метки и назначение ревьюеров в PR:
      Автоматизируйте триаж и назначение ответственных.

- [ ] Журналы передачи дежурства:
      Автоматически отправляйте сводки или дашборды перед каждой ротацией.

 - [ ] Анонимизация данных на стейджинге: 
       Автоматически очищайте прод-данные для использования в нижестоящих средах.

- [ ] Создание шаблона постмортема: 
      Запускайте шаблон и сбор таймлайна сразу после серьёзного инцидента.

- [ ] Slack- или email-нотификации о сбоях сборки:
      Мгновенный фидбек лучше, чем осознание поломки спустя часы.

- [ ] Резервные проверки здоровья API:
      Выявляйте нестабильные endpoint'ы, проверяя их из разных регионов.
---

Микросервисы — лучшие практики

1. Проектируй с учётом сбоев
➟ Микросервисы должны быть устойчивы к сбоям на всех уровнях — от инфраструктуры до отдельных сервисов.
➟ Используй подходы вроде circuit breaker'ов, bulkhead-паттернов и graceful degradation.

2. Держи сервисы маленькими и сфокусированными
➟ Каждый микросервис должен быть спроектирован для выполнения одной задачи и выполнять её хорошо.

3. Используй лёгкие протоколы обмена данными
➟ Микросервисы должны взаимодействовать друг с другом с помощью лёгких протоколов, таких как REST, gRPC или очереди сообщений.
➟ Это снижает накладные расходы и повышает производительность.

4. Реализуй сервис-дискавери
➟ Сервисы должны уметь динамически находить и вызывать друг друга.
➟ Используй реестры сервисов вроде Consul или Eureka, либо DNS-базированное обнаружение.

5. Автоматизируй тестирование и деплой
➟ Микросервисы должны быть полноценно покрыты тестами и разворачиваться автоматически с использованием CI/CD и автотестов.

6. Децентрализованное управление данными
➟ Данные должны храниться в том сервисе, которому они принадлежат, а не в общей базе.
➟ Это снижает связанность между сервисами и позволяет им эволюционировать независимо.

7. Превентивный мониторинг
➟ Чтобы понимать, как работают сервисы, собирай и анализируй метрики: задержки, пропускную способность, ошибки.
➟ Используй Prometheus, Grafana и другие инструменты для отслеживания состояния и раннего выявления проблем.

8. Безопасность на всех уровнях
➟ Безопасность должна быть встроена на всех уровнях архитектуры: инфраструктура, сервисы, коммуникация.
➟ Используй SSL/TLS, OAuth2, JWT и другие проверенные подходы.

9. Централизованный логгинг
➟ Все логи должны агрегироваться в одном месте — это упрощает отладку и анализ инцидентов.

10. Стандартизация процессов разработки
➟ Установи общие стандарты: стиль кода, фреймворки тестирования, порядок деплоя.
➟ Это обеспечивает единообразие и снижает количество ошибок.

11. Используй контейнеризацию
➟ Применяй Docker и Kubernetes для упрощения развёртывания и масштабирования сервисов.

12. Внедряй паттерны устойчивости (resiliency)
➟ В дополнение к отказоустойчивому дизайну, реализуй retry-политики, кэширование, load shedding и прочие шаблоны повышения надёжности.

13. Асинхронное взаимодействие
➟ Используй событийно-ориентированную архитектуру для снижения связности и повышения масштабируемости.

14. Чётко определяй API
➟ Каждый сервис должен предоставлять чётко описанный и легко понимаемый API.

Что бы ты добавил к этому списку?



